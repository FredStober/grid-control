#!/bin/bash
# | Copyright 2008-2017 Karlsruhe Institute of Technology
# |
# | Licensed under the Apache License, Version 2.0 (the "License");
# | you may not use this file except in compliance with the License.
# | You may obtain a copy of the License at
# |
# |     http://www.apache.org/licenses/LICENSE-2.0
# |
# | Unless required by applicable law or agreed to in writing, software
# | distributed under the License is distributed on an "AS IS" BASIS,
# | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# | See the License for the specific language governing permissions and
# | limitations under the License.

# Author: Fred Stober <grid-control-dev@googlegroups.com>
# Source: github.com/grid-control

# Error codes
# 100 - unspecified error

# 101 - file not found
# 102 - directory not found
# 103 - executable not found
# 104 - variable not found

# 105 - env unpacking failed
# 106 - se copy error
# 107 - killed by batch system
# 108 - output invalid

# 120 - lower space limit reached
# 121 - upper space limit reached
# 122 - min size failure

# 123 - user intervention requested

# >125 - reserved by POSIX

GC_VERSION="__GC_VERSION__"
GC_TRUE=0
GC_FALSE=1
export GC_LAST_ERR=""

debug_helper() {
	[ -z "$GC_DEBUG" ] && return
	OUTPUT="$(date +%s.%N):$$:shell:"
	for i in $(seq ${#BASH_LINENO[*]} -1 0); do
		[ -n "${BASH_LINENO[$i]}" ] && OUTPUT="$OUTPUT${BASH_LINENO[$i]} "
		[ -n "${BASH_SOURCE[$i]}" ] && OUTPUT="$OUTPUT$(basename ${BASH_SOURCE[$i]}):"
		[ -n "${FUNCNAME[$i]}" ] && OUTPUT="$OUTPUT${FUNCNAME[$i]}:"
	done
	CMD="$1"
	shift
	echo "$OUTPUT$LINENO - $CMD($@)" >&2
}

gc_trap_handler() {
	debug_helper "$FUNCNAME" "$@"
	echo "trapped signal $1 - aborting!" >&2
	abort
}

gc_trap() {
	debug_helper "$FUNCNAME" "$@"
	for GC_SIGNAL in 0 1 2 3 10 12 15; do
		trap "gc_trap_handler $GC_SIGNAL" $GC_SIGNAL
	done
}

gc_untrap() {
	debug_helper "$FUNCNAME" "$@"
	trap - 0 1 2 3 10 12 15
}

fail() {
	gc_untrap
	[ -n "$1" ] && CODE=$1 || CODE=$?
	GC_DEBUG="true"
	debug_helper "$FUNCNAME" "$@"
	touch "$GC_FAIL_MARKER"
	echo
	echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	echo "!! FAIL - FAIL - FAIL - FAIL !!"
	echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	echo "Error code $CODE"
	echo
	cleanup
	gc_update_job_info $CODE
	exit $CODE
}

abort() {
	gc_untrap
	GC_DEBUG="true"
	debug_helper "$FUNCNAME" "$@"
	touch "$GC_FAIL_MARKER"
	echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >> $GC_LANDINGZONE/gc.stderr
	echo "!!     DEBUG INFORMATION     !!" >> $GC_LANDINGZONE/gc.stderr
	echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >> $GC_LANDINGZONE/gc.stderr
	[ -d "$GC_LANDINGZONE" ] && checkdir "Start directory" "$GC_LANDINGZONE" >> $GC_LANDINGZONE/gc.stderr
	[ -d "$GC_SCRATCH" ] && checkdir "Scratch directory" "$GC_SCRATCH" >> $GC_LANDINGZONE/gc.stderr
	set >> $GC_LANDINGZONE/gc.stderr
	cleanup
	[ -n "$1" ] && gc_update_job_info $1
	[ -n "$(grep 'EXITCODE=0' $GC_LANDINGZONE/job.info)" ] && gc_update_job_info 100
	gc_untrap
	kill4sure $$
}

kill4sure() {
	debug_helper "$FUNCNAME" "$@"
	DEPTH=${2:-0}
	if [ $DEPTH -lt 10 ]; then
		(ps -o pid= --ppid $1 2> /dev/null) | while read XPID; do
			kill4sure $XPID $[$DEPTH + 1] &> /dev/null
		done
	fi
	echo "Killing process $1" >&2
	kill -15 $1 &> /dev/null
	sleep 1
	kill -9 $1 &> /dev/null
}

gc_update_job_info() {
	debug_helper "$FUNCNAME" "$@"
	if [ -d "$GC_LANDINGZONE" ]; then
		(
			echo "JOBID=$GC_JOB_ID"
			echo "EXITCODE=$1"
		) > $GC_LANDINGZONE/job.info
	fi
}

checkdir() {
	debug_helper "$FUNCNAME" "$@"
	echo -e "$1:\n$2"
	[ ! -d "$2" ] && echo "$1 not found" >&2 && fail 102
	[ "$2" == "invalid" ] && echo "Directory $1" >&2 && fail 102
	gc_get_pwd_physical $2 && echo "$1 content:" && ls -al $2 && df -hP $2 && echo
}

gc_check_file_exists() {
	debug_helper "$FUNCNAME" "$@"
	echo -n "Checking for file $1 ... "
	if [ ! -f "$1" ]; then
		echo "FAILED"
		echo "$(basename $1) missing" >&2
		fail 101
		return $GC_FALSE
	else
		echo "OK"
		return $GC_TRUE
	fi
}

gc_check_bin() {
	debug_helper "$FUNCNAME" "$@"
	[ "$(type -t $1)" == "function" ] && return "$GC_TRUE"
	echo -n "Checking for binary $1 ... " >&2
	if [ -x "$1" ]; then
		echo "OK" >&2
		return "$GC_TRUE"
	elif [ -x "$(gc_resolve_cmd $1)" ]; then
		echo "OK ($(gc_resolve_cmd $1))" >&2
		return "$GC_TRUE"
	else
		echo "FAILED" >&2
		gc_check_file_exists $1
		echo "$(basename $1) not executable" >&2
		return "$GC_FALSE"
	fi
}

checkvar() {
	debug_helper "$FUNCNAME" "$@"
	echo -n "Checking for variable \$$1 ... "
	if [ -z "${!1}" ]; then
		echo "FAILED"
		echo "$1 not set" >&2
		fail 104
	else
		echo "OK (\$$1 = ${!1})"
	fi
}

gc_get_pwd_physical() {
	debug_helper "$FUNCNAME" "$@"
	[ -d "$1" ] && cd $1 && pwd -P && cd $OLDPWD && return $GC_TRUE
	return $GC_FALSE
}

getdiskspace() # Get free space in mb
{
	TMPVAR="$(df -m -P $1 | awk 'END{print $4}')"
	echo "${TMPVAR:-0}"
}

getscratch() {
	debug_helper "$FUNCNAME" "$@"
	# find scratch directory with highest amount of disk space
	GC_SCRATCH="invalid"

	# getscratch_internal <list of variables> 
	# it will return with the path pointing at the biggest amount of free space
	# if no none of the directories exist, it returns 1
	getscratch_internal() {
		debug_helper "$FUNCNAME" "$@"
		GC_SCRATCH="invalid"
		GC_SCRATCHSIZE=-1
		# find scratch directory with highest amount of disk space
		for DIRVAR in $@;
		do
			# Is variable defined?
			if [ -n "${!DIRVAR}" ]; then
				DIR=${!DIRVAR}
				# If the variable points to a nonexisting directory continue with the other vars
				[ ! -d "$DIR" ] && continue
				# Make sure we can write to the directory
				rm -Rf "$DIR/$$" &> /dev/null
				mkdir -p "$DIR/$$" &> /dev/null
				if [ -d "$DIR/$$" ]; then
					# Get free space
					SIZE="$(getdiskspace $DIR/$$)" &> /dev/null
					# If it is the biggest space, use it!
					[ "$SIZE" -gt "$GC_SCRATCHSIZE" ] && GC_SCRATCH="$DIR/$$" && GC_SCRATCHSIZE="$SIZE" &> /dev/null
					rm -rf "$DIR/$$" &> /dev/null
				fi
			fi
		done
		# Was a scratch directory found?
		if [ "$GC_SCRATCHSIZE" -gt 0 ]; then
			mkdir -p "$GC_SCRATCH" &> /dev/null
			echo $GC_SCRATCH
			return $GC_TRUE;
		fi
		return $GC_FALSE;
	}

	getscratch_internal GC_SCRATCH && return $GC_TRUE
	getscratch_internal GC_LOCALSCRATCH && return $GC_TRUE
	getscratch_internal GC_LANDINGZONE && return $GC_TRUE
	getscratch_internal LOCAL_SCRATCH NODE_SCRATCH USER_SCRATCH EDG_WL_SCRATCH OSG_WN_TMP LCG_TMP DG_WL_SCRATCH && return $GC_TRUE

	echo "Site doesn't define scratch directory variables! Trying other locations..." >&2
	export >&2

	# FAIL or continue?
	#fail 123
	getscratch_internal GC_LANDINGZONE && return $GC_TRUE

	export GC_TMP="/tmp"
	getscratch_internal HOME TMPDIR GC_TMP && return $GC_TRUE

	fail 102
}

# Clean up user area
cleanup() {
	[ -z "$GC_DOCLEANUP" ] && return $GC_TRUE
	debug_helper "$FUNCNAME" "$@"
	[ -d "$GC_LANDINGZONE" ] && cd "$GC_LANDINGZONE"
	[ -f "$GC_MARKER" ] && rm -Rf "$GC_MARKER" &> /dev/null
	[ -d "$GC_SCRATCH" ] && rm -Rf "$GC_SCRATCH" &> /dev/null
}

# TODO: choose grid commands
gc_resolve_cmd() {
	debug_helper "$FUNCNAME" "$@"
	RESULT="$(which $@ 2> /dev/null | head -n 1)"
	echo ${RESULT:-$1}
}

my_move() {
	debug_helper "$FUNCNAME" "$@"
	[ ! -d "$1" ] && fail 102
	[ ! -d "$2" ] && fail 102
	[ -z "$(echo $3)" ] && return
	[ "$1" == "$2" ] && return
	echo "Move files from $1 to $2:"
	for file in `(cd $1 && ls $(eval "echo $3") && cd $OLDPWD) 2> /dev/null`; do
		echo -e " >> $file"
		test -f "$1/$file" && mv "$1/$file" "$2/$file"
	done
}

zip_files() {
	debug_helper "$FUNCNAME" "$@"

	for file in $@; do
		if [ -f "${file%.gz}" ] && [ ! -f "$file" ]; then
			echo "Zipping ${file%.gz}..."
			gzip -9f "${file%.gz}"
		fi
	done
}

display_short() {
	BASEAPP="$(which base64 2> /dev/null)"
	if [ -n "$BASEAPP" ]; then
		echo -n "(B64) "
		gzip -9 | $BASEAPP -w 0
		echo
	else
		cat
	fi
}

timestamp()
{
	debug_helper "$FUNCNAME" "$@"
	GC_TIME_LOG_NAME="$1"
	GC_TIME_LOG_EVENT="$1"
	GC_TIME_CUR="$(awk 'BEGIN { print systime() }')"
	echo "${GC_TIME_LOG_NAME}_$GC_TIME_LOG_EVENT=$GC_TIME_CUR" >> "$GC_LANDINGZONE/job.timestamps"
}

gc_log_time()
{
	debug_helper "$FUNCNAME" "$@"
	GC_TIME_LOG_NAME="$1"
	shift
	GC_TIME_CUR="$(awk 'BEGIN { print systime() }')"
	echo "${GC_TIME_LOG_NAME}_START=$GC_TIME_CUR" >> "$GC_LANDINGZONE/job.timestamps"
	"$@"
	GC_TIME_CUR="$(awk 'BEGIN { print systime() }')"
	echo "${GC_TIME_LOG_NAME}_DONE=$GC_TIME_CUR" >> "$GC_LANDINGZONE/job.timestamps"
}

timereport() {
	debug_helper "$FUNCNAME" "$@"
	echo "Job Timing information"
	echo "======================"
	cat $GC_LANDINGZONE/job.timestamps
	echo
	while read line; do
		echo "TIMESTAMP_$line" >> $GC_LANDINGZONE/job.info
	done < $GC_LANDINGZONE/job.timestamps
}
