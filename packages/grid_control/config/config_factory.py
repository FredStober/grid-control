# | Copyright 2014-2016 Karlsruhe Institute of Technology
# |
# | Licensed under the Apache License, Version 2.0 (the "License");
# | you may not use this file except in compliance with the License.
# | You may obtain a copy of the License at
# |
# |     http://www.apache.org/licenses/LICENSE-2.0
# |
# | Unless required by applicable law or agreed to in writing, software
# | distributed under the License is distributed on an "AS IS" BASIS,
# | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# | See the License for the specific language governing permissions and
# | limitations under the License.

import os, sys, logging
from grid_control.config.cfiller_base import CompatConfigFiller, DefaultFilesConfigFiller, DictConfigFiller, GeneralFileConfigFiller, MultiConfigFiller
from grid_control.config.cinterface_typed import SimpleConfigInterface
from grid_control.config.config_entry import ConfigContainer, ConfigError
from grid_control.config.cview_base import SimpleConfigView
from grid_control.gc_exceptions import GCLogHandler
from grid_control.utils import ensure_dir_exists, get_file_name, resolve_path
from grid_control.utils.data_structures import UniqueList
from grid_control.utils.file_objects import SafeFile
from python_compat import lfilter


# Main config interface
class ConfigFactory(object):
	def __init__(self, filler = None, config_file_path = None):
		def get_name(prefix = ''):
			if config_file_path:
				return ('%s.%s' % (prefix, get_file_name(config_file_path))).strip('.')
			elif prefix:
				return prefix
			return 'unnamed'

		try:
			path_main = os.getcwd()
		except Exception:
			raise ConfigError('The current directory does not exist!')
		if config_file_path:
			path_main = os.path.dirname(resolve_path(config_file_path,
				search_path_list = [os.getcwd()], exception_type = ConfigError))

		# Init config containers
		self._container_cur = ConfigContainer('current')
		if filler: # Read in the current configuration ...
			filler.fill(self._container_cur)
		self._container_cur.resolve() # resolve interpolations

		logging.getLogger('config.stored').propagate = False
		container_old = ConfigContainer('stored')
		container_old.enabled = False

		# Create config view and temporary config interface
		self._view = SimpleConfigView(get_name(), container_old, self._container_cur)
		self._view.config_vault['path:search'] = UniqueList([os.getcwd(), path_main])

		# Determine work directory using config interface with "global" scope
		tmp_config = SimpleConfigInterface(self._view.getView(setSections = ['global']))
		work_dir_base = tmp_config.getPath('workdir base', path_main, must_exist = False)
		path_work = tmp_config.getPath('workdir', os.path.join(work_dir_base, get_name('work')), must_exist = False)
		self._view.config_vault['path:workdir'] = path_work # tmp_config still has undefinied
		# Set dynamic plugin search path
		sys.path.extend(tmp_config.getPaths('plugin paths', [os.getcwd()]))

		# Determine and load stored config settings
		self._config_path_flat = os.path.join(path_work, 'current.conf') # Minimal config file
		self._config_path_old = os.path.join(path_work, 'work.conf') # Config file with saved settings
		if os.path.exists(self._config_path_old):
			GeneralFileConfigFiller([self._config_path_old]).fill(container_old)
			CompatConfigFiller(os.path.join(path_work, 'task.dat')).fill(container_old)
			container_old.enabled = True
			container_old.set_read_only()

		# Get persistent variables - only possible after container_old was enabled
		self._view.setConfigName(tmp_config.get('config id', get_name(), persistent = True))


	def get_config(self):
		result = SimpleConfigInterface(self._view)
		result.factory = self
		return result


	def _write_file(self, fn, message = None, **kwargs):
		fp = SafeFile(fn, 'w')
		if message is not None:
			fp.write(message)
		self._view.write(fp, **kwargs)
		fp.close()


	def freeze(self, write_config = True):
		self._container_cur.set_read_only()
		# Inform the user about unused options
		unused = lfilter(lambda entry: ('!' not in entry.section) and not entry.accessed, self._view.iterContent())
		log = logging.getLogger('config.freeze')
		if unused:
			log.log(logging.INFO1, 'There are %s unused config options!', len(unused))
		for entry in unused:
			log.log(logging.INFO1, '\t%s', entry.format(print_section = True))
		if write_config or not os.path.exists(self._config_path_old):
			ensure_dir_exists(os.path.dirname(self._config_path_old), 'config storage directory', ConfigError)
			# Write user friendly, flat config file and config file with saved settings
			self._write_file(self._config_path_flat, print_default = False, printUnused = False, printMinimal = True,
				printWorkdir = True)
			self._write_file(self._config_path_old,  print_default = True,  printUnused = True,  printMinimal = True, printSource = True,
				message = '; ==> DO NOT EDIT THIS FILE! <==\n; This file is used to find config changes!\n')


def create_config(configFile = None, configDict = None, useDefaultFiles = False, additional = None, register = False):
	fillerList = []
	if useDefaultFiles:
		fillerList.append(DefaultFilesConfigFiller())
	if configFile:
		fillerList.append(GeneralFileConfigFiller([configFile]))
	if configDict:
		fillerList.append(DictConfigFiller(configDict))
	fillerList.extend(additional or [])
	config = ConfigFactory(MultiConfigFiller(fillerList), configFile).get_config()
	if register:
		GCLogHandler.config_instances.append(config)
	return config
